<!DOCTYPE html> <html> <head> <meta http-equiv="Content-Type" content="text/html; charset=UTF-8"> <meta charset="utf-8"> <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"> <meta http-equiv="X-UA-Compatible" content="IE=edge"> <title>Lieb Robinson Bounds and Many-Body Scars | Pranav Kairon</title> <meta name="author" content="Pranav Kairon"> <meta name="description" content="limits on the spread of information in quantum systems"> <meta name="keywords" content="jekyll, jekyll-theme, academic-website, portfolio-website"> <meta property="og:site_name" content="Pranav Kairon"> <meta property="og:type" content="website"> <meta property="og:title" content="Pranav Kairon | Lieb Robinson Bounds and Many-Body Scars"> <meta property="og:url" content="https://pranav997.github.io/projects/lieb/"> <meta property="og:description" content="limits on the spread of information in quantum systems"> <meta property="og:locale" content="en"> <meta name="twitter:card" content="summary"> <meta name="twitter:title" content="Lieb Robinson Bounds and Many-Body Scars"> <meta name="twitter:description" content="limits on the spread of information in quantum systems"> <link href="https://cdn.jsdelivr.net/npm/bootstrap@4.6.1/dist/css/bootstrap.min.css" rel="stylesheet" integrity="sha256-DF7Zhf293AJxJNTmh5zhoYYIMs2oXitRfBjY+9L//AY=" crossorigin="anonymous"> <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/mdbootstrap@4.20.0/css/mdb.min.css" integrity="sha256-jpjYvU3G3N6nrrBwXJoVEYI/0zw8htfFnhT9ljN3JJw=" crossorigin="anonymous"> <link defer rel="stylesheet" href="https://unpkg.com/bootstrap-table@1.21.4/dist/bootstrap-table.min.css"> <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6.4.0/css/all.min.css" integrity="sha256-HtsXJanqjKTc8vVQjO4YMhiqFoXkfBsjBWcX91T1jr8=" crossorigin="anonymous"> <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/academicons@1.9.1/css/academicons.min.css" integrity="sha256-i1+4qU2G2860dGGIOJscdC30s9beBXjFfzjWLjBRsBg=" crossorigin="anonymous"> <link rel="stylesheet" type="text/css" href="https://fonts.googleapis.com/css?family=Roboto:300,400,500,700|Roboto+Slab:100,300,400,500,700|Material+Icons"> <link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/jwarby/jekyll-pygments-themes@master/github.css" media="" id="highlight_theme_light"> <link rel="shortcut icon" href="data:image/svg+xml,&lt;svg%20xmlns=%22http://www.w3.org/2000/svg%22%20viewBox=%220%200%20100%20100%22&gt;&lt;text%20y=%22.9em%22%20font-size=%2290%22&gt;%E2%9A%9B%EF%B8%8F&lt;/text&gt;&lt;/svg&gt;"> <link rel="stylesheet" href="/assets/css/main.css?d41d8cd98f00b204e9800998ecf8427e"> <link rel="canonical" href="https://pranav997.github.io/projects/lieb/"> <link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/jwarby/jekyll-pygments-themes@master/native.css" media="none" id="highlight_theme_dark"> <script src="/assets/js/theme.js?96d6b3e1c3604aca8b6134c7afdd5db6"></script> <script src="/assets/js/dark_mode.js?9b17307bb950ffa2e34be0227f53558f"></script> <script src="https://cdn.jsdelivr.net/npm/jquery@3.6.0/dist/jquery.min.js" integrity="sha256-/xUj+3OJU5yExlq6GSYGSHk7tPXikynS7ogEvDej/m4=" crossorigin="anonymous"></script> <script type="text/javascript">window.MathJax={tex:{tags:"ams"}};</script> <script defer type="text/javascript" id="MathJax-script" src="https://cdn.jsdelivr.net/npm/mathjax@3.2.0/es5/tex-mml-chtml.js"></script> <script defer src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script> <script src="/assets/js/distillpub/template.v2.js"></script> <script src="/assets/js/distillpub/transforms.v2.js"></script> <script src="/assets/js/distillpub/overrides.js"></script> <style type="text/css">.fake-img{background:#bbb;border:1px solid rgba(0,0,0,0.1);box-shadow:0 0 4px rgba(0,0,0,0.1);margin-bottom:12px}.fake-img p{font-family:monospace;color:white;text-align:left;margin:12px 0;text-align:center;font-size:16px}</style> </head> <body> <d-front-matter> <script async type="text/json">{
      "title": "Lieb Robinson Bounds and Many-Body Scars",
      "description": "limits on the spread of information in quantum systems",
      "published": "November 9, 2023",
      "authors": [
        {
          "author": "Pranav",
          "authorURL": "",
          "affiliations": [
            {
              "name": "",
              "url": ""
            }
          ]
        }
        
      ],
      "katex": {
        "delimiters": [
          {
            "left": "$",
            "right": "$",
            "display": false
          },
          {
            "left": "$$",
            "right": "$$",
            "display": true
          }
        ]
      }
    }</script> </d-front-matter> <header> <nav id="navbar" class="navbar navbar-light navbar-expand-sm fixed-top"> <div class="container"> <a class="navbar-brand title font-weight-lighter" href="/">Pranav Kairon</a> <button class="navbar-toggler collapsed ml-auto" type="button" data-toggle="collapse" data-target="#navbarNav" aria-controls="navbarNav" aria-expanded="false" aria-label="Toggle navigation"> <span class="sr-only">Toggle navigation</span> <span class="icon-bar top-bar"></span> <span class="icon-bar middle-bar"></span> <span class="icon-bar bottom-bar"></span> </button> <div class="collapse navbar-collapse text-right" id="navbarNav"> <ul class="navbar-nav ml-auto flex-nowrap"> <li class="nav-item "> <a class="nav-link" href="/">About</a> </li> <li class="nav-item "> <a class="nav-link" href="/publications/">Publications</a> </li> <li class="nav-item "> <a class="nav-link" href="/projects/">Projects</a> </li> <li class="nav-item "> <a class="nav-link" href="/cv/">CV</a> </li> <li class="toggle-container"> <button id="light-toggle" title="Change theme"> <i class="fas fa-moon"></i> <i class="fas fa-sun"></i> </button> </li> </ul> </div> </div> </nav> <progress id="progress" value="0"> <div class="progress-container"> <span class="progress-bar"></span> </div> </progress> </header> <div class="post distill"> <d-title> <h1>Lieb Robinson Bounds and Many-Body Scars</h1> <p>limits on the spread of information in quantum systems</p> </d-title> <d-byline></d-byline> <d-article> <p>I had known about Lieb Robinson bounds previously because of the HHKL algorithm <d-cite key="haah2021quantum"></d-cite>. But I never thought of going into depth, until I attended a talk by Prof. Mari Carmen Bañuls, where she talked about one of her papers titled “Light cone tensor network and time evolution” <d-cite key="mari_light"></d-cite> . This sort of reintroduced me to the idea, of how there are bounds on the speed with which information spreads in a quantum system. There are great reviews/notes available for a graduate level introduction to this topic <d-cite key="chen2023speed,hastings2010locality"></d-cite>. Andy Lucas does a nice job of summarizing it in this Boulder summer school <a href="https://www.youtube.com/watch?v=2gktIZpPhSM" rel="external nofollow noopener" target="_blank">lecture</a>. I have prepared some handwritten notes for the lecture in case people find them helpful <a href="/assets/pdf/LB_Bounds.pdf">PDF</a>.However, in this post I will talk about what I understand/find interesting about LB bound.</p> <p>So we consider a local Hamiltonian of the form \(\mathcal{H}=\sum h_x\) defined on \(n\) qubits. We have a Hilbert space with \(2^n\) dimensions such that time evolution of an initial state \(|\psi(0)\rangle\) is given by \(|\psi(t)\rangle=e^{-i\mathcal{H}t}|\psi(0)\rangle\). We are interested in the spread of information in the system. The implementation of such unitaries on a quantum computer is considered efficient if, Unitary \(U\) can be implemented in time \(t\) with a number of gates \(g\) such that \(g\leq poly(n)\) and \(t\leq poly(n)\). The trick is to decompose continuos time evolutions into discrete steps such that discrete steps commute, this is known as Trotterization.</p> <details><summary>Trotterization example</summary> <p>Let’s say we want to evolve a Hamiltonian given by \(\mathcal{H}=\sum_{i} J(X_{i}X_{i+1} + Y_{i}Y_{i+1}+ Z_{i}Z_{i+1})\) for time \(t\). We can decompose the time evolution into \(N\) steps of size \(\delta t=t/N\) where \(N\) is the number of steps. We can write \(U=e^{-i\mathcal{H}t}\) as \(U=[e^{-i\sum_{i}J\delta t(X_{i}X_{i+1})}e^{-i\sum_{i}J\delta t(Y_{i}Y_{i+1})}e^{-i\sum_{i}J\delta t(Z_{i}Z_{i+1})}]^N\)</p> </details> <hr> <h2 id="simple-example-of-a-lieb-robinson-bound">Simple example of a Lieb Robinson bound</h2> <p>Consider a simpler example of a electron hopping on a tight binding lattice with nearest neighbour interactions, \(\mathcal{H}=\sum_{n} J(|n\rangle \langle n+1|+|n+1\rangle \langle n|)\). The dispersion relation is given by \(\epsilon_k=-2t\cos{ka}\) where \(k\) is the electron momentum. Hence, the maxmimum group velocity can be derived as \(v_g= \frac{dw}{dk} \leq 2ta\). If we have a 1D lattice, then the maximum speed with which information can spread is \(2ta\). An interesting question to ask is how does a perturbation at one site spread through the lattice. This can be measured by observing the difference between the unperturbed time evolved state \(|\psi(t)\rangle=e^{-i\mathcal{H}t}|\psi(0)\rangle\) with the perturbed state \(|\psi(t)\rangle=e^{-i\mathcal{H}t}e^{-iX_0}|\psi(0)\rangle\).</p> <h3 id="many-body-scars">Many-Body Scars</h3> <p>Before we dive into many-body scar states, it’s essential to understand the broader context of thermalization in quantum systems.</p> <h4 id="thermalization-in-quantum-systems">Thermalization in Quantum Systems</h4> <p>In quantum mechanics, thermalization refers to the process where a closed quantum system evolves towards thermal equilibrium. This is typically observed in systems with many degrees of freedom. The Eigenstate Thermalization Hypothesis (ETH) suggests that individual eigenstates of a quantum system at high energy densities are thermal.</p> <p><strong>Eigenstate Thermalization Hypothesis (ETH):</strong> \(\langle \psi | \hat{O} | \psi \rangle \approx \text{Tr}(\rho_{\text{thermal}} \hat{O}),\) where \(\hat{O}\) is an observable, \(\psi\) is an eigenstate, and \(\rho_{\text{thermal}}\) is the thermal state.</p> <p>However, not all systems follow the ETH. Two significant exceptions are:</p> <ol> <li> <p><strong>Many-Body Localization (MBL):</strong> In systems with sufficient disorder, local conserved quantities prevent the system from thermalizing. In MBL systems, eigenstates are non-ergodic.</p> </li> <li> <p><strong>Integrable Systems:</strong> These systems have extensively many conserved quantities that prevent them from reaching thermal equilibrium.</p> </li> </ol> <h4 id="many-body-scar-states">Many-Body Scar States</h4> <p>Now, let’s focus on many-body scar states, a relatively recent discovery that presents an exception to typical thermalization behavior. This section is inspired from <a href="https://www.youtube.com/watch?v=mzc02ROdr3E" rel="external nofollow noopener" target="_blank">Fiona Burnell’s talk</a> on many body scar states. I will continue to update it as I read more and more about this exciting topic.</p> <p><strong>Definition:</strong> Many-body scar states are special eigenstates in a non-integrable quantum system that do not thermalize, despite the absence of apparent conserved quantities. These states lead to weak ergodicity breaking.</p> <p><strong>Characteristics:</strong></p> <ol> <li> <p><strong>Prethermalization:</strong> The system initially shows signs of thermalization but eventually deviates from it due to the presence of scar states. It is a phase between thermalization and non-thermalization</p> </li> <li> <p><strong>Quantum Recurrences:</strong> The system periodically returns to a state close to its initial state.</p> </li> <li> <p><strong>Entanglement Entropy:</strong> Scar states exhibit sub-volume law entanglement, unlike typical thermal states that follow a volume law.</p> </li> </ol> <p><strong>Hamiltonian Representation:</strong></p> <p>Consider a local Hamiltonian \(H\) of a many-body system: \(H \sim c^L \quad \text{(exponentially many thermal eigenstates)},\) where \(L\) is the system size, and \(c\) is a constant. For scar states, the Hamiltonian can be represented as: \(H_{\text{scar}} \sim L^n \quad \text{(polynomially many thermal scar eigenstates)},\) indicating a polynomial number of these special eigenstates.</p> <p><strong>Entanglement Entropy Calculation:</strong></p> <p>For a system size \(L\) and a spin \(s\), the Hamiltonian can be represented as: \(H \sim (2s + 1)^L.\) To compute the half-chain entanglement entropy \(S\) for all eigenstates, we use the reduced density matrix (RDM) of a subsystem \(A\): \(S_A = -\text{Tr}(\rho_A \log \rho_A),\) where \(\rho_A\) is the RDM of subsystem \(A\).</p> <p>Continuing from our previous discussion on many-body scar states, let’s delve into the specifics of their experimental relevance, structural characteristics, and the significance of Hamiltonian terms in their identification and analysis. Before this let us first see the sub volume law entanglement in scar states. Here I have plotted the entanglement entropy for a system of 18 spins. The entanglement entropy is plotted against the normalized eigenvalue spectrum. We can see that the entanglement entropy is much lower than the thermal entropy for some states. The specific Hamiltonian used here is the PXP model, where \(H=\sum_{i} P_{i-1} X_{i} P_{i+1}\), where \(P_i=\frac{\mathcal{I}-Z}{2}\) is the projector onto the \(i\)th spin being down. The code to generate the plot is given below.</p> <div class="row"> <div class="col-sm mt-3 mt-md-0"> <figure> <picture> <source class="responsive-img-srcset" media="(max-width: 480px)" srcset="/assets/img/sa_vs_e_scar-480.webp"></source> <source class="responsive-img-srcset" media="(max-width: 800px)" srcset="/assets/img/sa_vs_e_scar-800.webp"></source> <source class="responsive-img-srcset" media="(max-width: 1400px)" srcset="/assets/img/sa_vs_e_scar-1400.webp"></source> <img src="/assets/img/sa_vs_e_scar.png" width="auto" height="auto" title="Entanglement entropy (half of subsystem) plotted against normalized eigenvalue spectrum" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"> </picture> </figure> </div> </div> <div class="caption"> Entanglement entropy (half of subsystem) plotted against normalized eigenvalue spectrum </div> <details><summary>Code to generate the plot above</summary> <figure class="highlight"><pre><code class="language-python" data-lang="python"><span class="kn">from</span> <span class="n">quspin.operators</span> <span class="kn">import</span> <span class="n">hamiltonian</span>
<span class="kn">from</span> <span class="n">quspin.basis</span> <span class="kn">import</span> <span class="n">spin_basis_1d</span> <span class="c1"># Hilbert space spin basis_1d
</span><span class="kn">from</span> <span class="n">quspin.basis.user</span> <span class="kn">import</span> <span class="n">user_basis</span> <span class="c1"># Hilbert space user basis
</span><span class="kn">from</span> <span class="n">quspin.basis.user</span> <span class="kn">import</span> <span class="n">pre_check_state_sig_32</span><span class="p">,</span><span class="n">op_sig_32</span><span class="p">,</span><span class="n">map_sig_32</span> <span class="c1"># user basis data types
</span><span class="kn">from</span> <span class="n">numba</span> <span class="kn">import</span> <span class="n">carray</span><span class="p">,</span><span class="n">cfunc</span> <span class="c1"># numba helper functions
</span><span class="kn">from</span> <span class="n">numba</span> <span class="kn">import</span> <span class="n">uint32</span><span class="p">,</span><span class="n">int32</span> <span class="c1"># numba data types
</span><span class="kn">import</span> <span class="n">numpy</span> <span class="k">as</span> <span class="n">np</span>
<span class="kn">import</span> <span class="n">matplotlib.pyplot</span> <span class="k">as</span> <span class="n">plt</span>
<span class="kn">import</span> <span class="n">sys</span><span class="p">,</span> <span class="n">os</span>
<span class="n">quspin_path</span> <span class="o">=</span> <span class="n">os</span><span class="p">.</span><span class="n">path</span><span class="p">.</span><span class="nf">join</span><span class="p">(</span><span class="n">os</span><span class="p">.</span><span class="nf">getcwd</span><span class="p">(),</span><span class="sh">"</span><span class="s">../../</span><span class="sh">"</span><span class="p">)</span>
<span class="n">sys</span><span class="p">.</span><span class="n">path</span><span class="p">.</span><span class="nf">insert</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="n">quspin_path</span><span class="p">)</span>

<span class="n">N</span> <span class="o">=</span> <span class="mi">18</span> <span class="c1"># total number of lattice sites
</span>
<span class="c1">#
</span>
<span class="c1">###### function to call when applying operators
</span>
<span class="nd">@cfunc</span><span class="p">(</span><span class="n">op_sig_32</span><span class="p">,</span> <span class="nb">locals</span><span class="o">=</span><span class="nf">dict</span><span class="p">(</span><span class="n">s</span><span class="o">=</span><span class="n">int32</span><span class="p">,</span><span class="n">b</span><span class="o">=</span><span class="n">uint32</span><span class="p">))</span>
<span class="k">def</span> <span class="nf">op</span><span class="p">(</span><span class="n">op_struct_ptr</span><span class="p">,</span><span class="n">op_str</span><span class="p">,</span><span class="n">ind</span><span class="p">,</span><span class="n">N</span><span class="p">,</span><span class="n">args</span><span class="p">):</span>
    <span class="c1"># using struct pointer to pass op_struct_ptr back to C++ see numba Records
</span>    <span class="n">op_struct</span> <span class="o">=</span> <span class="n">carray</span><span class="p">[</span><span class="n">op_struct_ptr</span><span class="p">,</span><span class="mi">1</span><span class="p">](</span><span class="mi">0</span><span class="p">)</span>
    <span class="n">err</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">ind</span> <span class="o">=</span> <span class="n">N</span> <span class="o">-</span> <span class="n">ind</span> <span class="o">-</span> <span class="mi">1</span> <span class="c1"># convention for QuSpin for mapping from bits to sites.
</span>    <span class="n">s</span> <span class="o">=</span> <span class="p">(((</span><span class="n">op_struct</span><span class="p">.</span><span class="n">state</span><span class="o">&gt;&gt;</span><span class="n">ind</span><span class="p">)</span><span class="o">&amp;</span><span class="mi">1</span><span class="p">)</span><span class="o">&lt;&lt;</span><span class="mi">1</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span>
    <span class="n">b</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span><span class="o">&lt;&lt;</span><span class="n">ind</span><span class="p">)</span>
    <span class="c1">#
</span>    <span class="k">if</span> <span class="n">op_str</span><span class="o">==</span><span class="mi">120</span><span class="p">:</span> <span class="c1"># "x" is integer value 120 (check with ord("x"))
</span>        <span class="n">op_struct</span><span class="p">.</span><span class="n">state</span> <span class="o">^=</span> <span class="n">b</span>
    <span class="k">elif</span> <span class="n">op_str</span><span class="o">==</span><span class="mi">121</span><span class="p">:</span> <span class="c1"># "y" is integer value 120 (check with ord("y"))
</span>        <span class="n">op_struct</span><span class="p">.</span><span class="n">state</span> <span class="o">^=</span> <span class="n">b</span>
        <span class="n">op_struct</span><span class="p">.</span><span class="n">matrix_ele</span> <span class="o">*=</span> <span class="mf">1.0j</span><span class="o">*</span><span class="n">s</span>
    <span class="k">elif</span> <span class="n">op_str</span><span class="o">==</span><span class="mi">122</span><span class="p">:</span> <span class="c1"># "z" is integer value 120 (check with ord("z"))
</span>        <span class="n">op_struct</span><span class="p">.</span><span class="n">matrix_ele</span> <span class="o">*=</span> <span class="n">s</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">op_struct</span><span class="p">.</span><span class="n">matrix_ele</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">err</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>
    <span class="c1">#
</span>    <span class="k">return</span> <span class="n">err</span>

<span class="c1">#
</span>
<span class="n">op_args</span><span class="o">=</span><span class="n">np</span><span class="p">.</span><span class="nf">array</span><span class="p">([],</span><span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="p">.</span><span class="n">uint32</span><span class="p">)</span>

<span class="c1">#
</span>
<span class="c1">###### function to filter states/project states out of the basis
</span>
<span class="c1">#
</span>
<span class="nd">@cfunc</span><span class="p">(</span><span class="n">pre_check_state_sig_32</span><span class="p">,</span>
    <span class="nb">locals</span><span class="o">=</span><span class="nf">dict</span><span class="p">(</span><span class="n">s_shift_left</span><span class="o">=</span><span class="n">uint32</span><span class="p">,</span><span class="n">s_shift_right</span><span class="o">=</span><span class="n">uint32</span><span class="p">),</span> <span class="p">)</span>
<span class="k">def</span> <span class="nf">pre_check_state</span><span class="p">(</span><span class="n">s</span><span class="p">,</span><span class="n">N</span><span class="p">,</span><span class="n">args</span><span class="p">):</span>
    <span class="sh">"""</span><span class="s"> imposes that that a bit with 1 must be preceded and followed by 0,
    i.e. a particle on a given site must have empty neighboring sites.
    #
    Works only for lattices of up to N=32 sites (otherwise, change mask)
    #
    </span><span class="sh">"""</span>
    <span class="n">mask</span> <span class="o">=</span> <span class="p">(</span><span class="mh">0xffffffff</span> <span class="o">&gt;&gt;</span> <span class="p">(</span><span class="mi">32</span> <span class="o">-</span> <span class="n">N</span><span class="p">))</span> <span class="c1"># works for lattices of up to 32 sites
</span>    <span class="c1"># cycle bits left by 1 periodically
</span>    <span class="n">s_shift_left</span> <span class="o">=</span> <span class="p">(((</span><span class="n">s</span> <span class="o">&lt;&lt;</span> <span class="mi">1</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">mask</span><span class="p">)</span> <span class="o">|</span> <span class="p">((</span><span class="n">s</span> <span class="o">&gt;&gt;</span> <span class="p">(</span><span class="n">N</span> <span class="o">-</span> <span class="mi">1</span><span class="p">))</span> <span class="o">&amp;</span> <span class="n">mask</span><span class="p">))</span>
    <span class="c1">#
</span>    <span class="c1"># cycle bits right by 1 periodically
</span>    <span class="n">s_shift_right</span> <span class="o">=</span> <span class="p">(((</span><span class="n">s</span> <span class="o">&gt;&gt;</span> <span class="mi">1</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">mask</span><span class="p">)</span> <span class="o">|</span> <span class="p">((</span><span class="n">s</span> <span class="o">&lt;&lt;</span> <span class="p">(</span><span class="n">N</span> <span class="o">-</span> <span class="mi">1</span><span class="p">))</span> <span class="o">&amp;</span> <span class="n">mask</span><span class="p">))</span>
    <span class="c1">#
</span>    <span class="nf">return </span><span class="p">(((</span><span class="n">s_shift_right</span><span class="o">|</span><span class="n">s_shift_left</span><span class="p">)</span><span class="o">&amp;</span><span class="n">s</span><span class="p">))</span><span class="o">==</span><span class="mi">0</span>

<span class="c1">#
</span>
<span class="n">pre_check_state_args</span><span class="o">=</span><span class="bp">None</span>

<span class="c1">#
</span>
<span class="c1">###### construct user_basis
</span>
<span class="c1"># define maps dict
</span>
<span class="n">maps</span> <span class="o">=</span> <span class="nf">dict</span><span class="p">()</span> <span class="c1"># no symmetries to apply.
</span>
<span class="c1"># define op_dict
</span>
<span class="n">op_dict</span> <span class="o">=</span> <span class="nf">dict</span><span class="p">(</span><span class="n">op</span><span class="o">=</span><span class="n">op</span><span class="p">,</span><span class="n">op_args</span><span class="o">=</span><span class="n">op_args</span><span class="p">)</span>

<span class="c1"># define pre_check_state
</span>
<span class="n">pre_check_state</span><span class="o">=</span><span class="p">(</span><span class="n">pre_check_state</span><span class="p">,</span><span class="n">pre_check_state_args</span><span class="p">)</span> <span class="c1"># None gives a null pointer to args
</span>
<span class="c1"># create user basis
</span>
<span class="n">basis</span> <span class="o">=</span> <span class="nf">user_basis</span><span class="p">(</span><span class="n">np</span><span class="p">.</span><span class="n">uint32</span><span class="p">,</span><span class="n">N</span><span class="p">,</span><span class="n">op_dict</span><span class="p">,</span><span class="n">allowed_ops</span><span class="o">=</span><span class="nf">set</span><span class="p">(</span><span class="sh">"</span><span class="s">xyz</span><span class="sh">"</span><span class="p">),</span><span class="n">sps</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span>
                    <span class="n">pre_check_state</span><span class="o">=</span><span class="n">pre_check_state</span><span class="p">,</span><span class="n">Ns_block_est</span><span class="o">=</span><span class="mi">300000</span><span class="p">,</span><span class="o">**</span><span class="n">maps</span><span class="p">)</span>

<span class="c1"># print basis
</span>
<span class="nf">print</span><span class="p">(</span><span class="n">basis</span><span class="p">)</span>

<span class="c1">#
</span>
<span class="c1">###### construct Hamiltonian
</span>
<span class="c1"># site-coupling lists
</span>
<span class="n">h_list</span>  <span class="o">=</span> <span class="p">[[</span><span class="mf">1.0</span><span class="p">,</span><span class="n">i</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nf">range</span><span class="p">(</span><span class="n">N</span><span class="p">)]</span>

<span class="c1"># operator string lists
</span>
<span class="n">static</span> <span class="o">=</span> <span class="p">[[</span><span class="sh">"</span><span class="s">x</span><span class="sh">"</span><span class="p">,</span><span class="n">h_list</span><span class="p">],]</span>

<span class="c1"># compute Hamiltonian, no checks have been implemented
</span>
<span class="n">no_checks</span><span class="o">=</span><span class="nf">dict</span><span class="p">(</span><span class="n">check_symm</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span> <span class="n">check_pcon</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span> <span class="n">check_herm</span><span class="o">=</span><span class="bp">False</span><span class="p">)</span>
<span class="n">H</span> <span class="o">=</span> <span class="nf">hamiltonian</span><span class="p">(</span><span class="n">static</span><span class="p">,[],</span><span class="n">basis</span><span class="o">=</span><span class="n">basis</span><span class="p">,</span><span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="p">.</span><span class="n">float64</span><span class="p">,</span><span class="o">**</span><span class="n">no_checks</span><span class="p">)</span>

<span class="c1"># compute eigenvalues and eigenvectors
</span>
<span class="n">E</span><span class="p">,</span><span class="n">V</span> <span class="o">=</span> <span class="n">H</span><span class="p">.</span><span class="nf">eigh</span><span class="p">()</span>

<span class="c1"># compute entanglement entropy
</span>
<span class="n">Sa</span><span class="o">=</span><span class="n">np</span><span class="p">.</span><span class="nf">array</span><span class="p">([</span><span class="n">basis</span><span class="p">.</span><span class="nf">ent_entropy</span><span class="p">(</span><span class="n">V</span><span class="p">[:,</span><span class="n">i</span><span class="p">],</span><span class="n">sub_sys_A</span><span class="o">=</span><span class="nf">range</span><span class="p">(</span><span class="n">N</span><span class="o">//</span><span class="mi">2</span><span class="p">))[</span><span class="sh">'</span><span class="s">Sent_A</span><span class="sh">'</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nf">range</span><span class="p">(</span><span class="n">V</span><span class="p">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">])])</span>

<span class="c1"># use latex for labels
</span>
<span class="n">plt</span><span class="p">.</span><span class="nf">rc</span><span class="p">(</span><span class="sh">'</span><span class="s">text</span><span class="sh">'</span><span class="p">,</span> <span class="n">usetex</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
<span class="n">plt</span><span class="p">.</span><span class="nf">rc</span><span class="p">(</span><span class="sh">'</span><span class="s">font</span><span class="sh">'</span><span class="p">,</span> <span class="n">family</span><span class="o">=</span><span class="sh">'</span><span class="s">serif</span><span class="sh">'</span><span class="p">)</span>
<span class="n">plt</span><span class="p">.</span><span class="nf">rc</span><span class="p">(</span><span class="sh">'</span><span class="s">font</span><span class="sh">'</span><span class="p">,</span> <span class="n">size</span><span class="o">=</span><span class="mi">20</span><span class="p">)</span>
<span class="n">plt</span><span class="p">.</span><span class="nf">plot</span><span class="p">(</span><span class="n">E</span><span class="o">/</span><span class="n">N</span><span class="p">,</span><span class="n">Sa</span><span class="p">,</span><span class="sh">'</span><span class="s">o</span><span class="sh">'</span><span class="p">,</span><span class="n">markersize</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span><span class="n">markerfacecolor</span><span class="o">=</span><span class="sh">'</span><span class="s">b</span><span class="sh">'</span><span class="p">,</span><span class="n">markeredgecolor</span><span class="o">=</span><span class="sh">'</span><span class="s">k</span><span class="sh">'</span><span class="p">)</span>
<span class="n">plt</span><span class="p">.</span><span class="nf">xlabel</span><span class="p">(</span><span class="sa">r</span><span class="sh">'</span><span class="s">$E/N$</span><span class="sh">'</span><span class="p">)</span>
<span class="n">plt</span><span class="p">.</span><span class="nf">ylabel</span><span class="p">(</span><span class="sa">r</span><span class="sh">'</span><span class="s">$S_A$</span><span class="sh">'</span><span class="p">)</span>
<span class="n">plt</span><span class="p">.</span><span class="nf">grid</span><span class="p">(</span><span class="bp">True</span><span class="p">)</span></code></pre></figure> </details> <h3 id="experimental-relevance-of-many-body-scar-states">Experimental Relevance of Many-Body Scar States</h3> <p>Many-body scar states have garnered significant interest due to their experimental observability and unusual dynamics. A key example is the 2017 experiment by Lukin’s group, which demonstrated these properties <d-cite key="bernien2017probing"></d-cite>.</p> <h4 id="lukins-2017-experiment">Lukin’s 2017 Experiment</h4> <p>In this experiment, an initially antiferromagnetic configuration, corresponding to a very high temperature, was expected to relax rapidly to a thermal state. However, the observation of long-lived states indicated the presence of many-body scars.</p> <p><strong>Experiment Observation:</strong> \(\text{Initial State: Antiferromagnetic} \implies \text{Expected: Rapid Thermalization} \implies \text{Observed: Long-lived States}\)</p> <p>This unexpected behavior underscores the importance of understanding scar states, as they can lead to significant deviations from expected thermalization dynamics in quantum systems.</p> <h3 id="structural-analysis-of-many-body-scar-states">Structural Analysis of Many-Body Scar States</h3> <p>To understand the structure and formation of scar states, we analyze the Hamiltonian of the system, which can be decomposed into three parts: \(H = H_c + H_s + H_a\).</p> <h4 id="hamiltonian-components">Hamiltonian Components</h4> <ol> <li> <p><strong>\(H_c\):</strong> This term has a non-abelian symmetry, providing a foundational structure for the system.</p> </li> <li> <p><strong>\(H_s\):</strong> This term removes degeneracies by assigning different energies to various states, helping isolate the scar states.</p> </li> <li> <p><strong>\(H_a\):</strong> A special symmetry-breaking term, \(H_a\) makes the model appear generic away from the scar subspace and is crucial for annihilating all scar states.</p> </li> </ol> <p><strong>Hamiltonian Representation:</strong> \(H = H_c + H_s + H_a\)</p> <h4 id="su2-invariance-and-thermal-properties">SU(2) Invariance and Thermal Properties</h4> <p>Consider a system with SU(2) invariance. Due to spin conservation symmetry, the Hamiltonian is divided into multiple blocks. To analyze thermal properties, we focus on individual blocks, noting that some blocks are small and contain approximately \(L\) states.</p> <p><strong>Block Analysis in SU(2) Invariant System:</strong> \(\text{SU(2) Invariance} \implies \text{Multiple Blocks due to Spin Conservation} \implies \text{Analyze Thermal Properties within Each Block}\)</p> <h4 id="identifying-scar-states">Identifying Scar States</h4> <p>Scar states can be identified as a small multiplet of states isolated by symmetry. The non-generic symmetry-breaking term \(H_a\) plays a crucial role in this process by annihilating these scar states while mixing up all symmetry sectors.</p> <p><strong>Scar State Identification:</strong> \(\text{Candidate Scar States} = \text{Small Multiplet Isolated by Symmetry} \xrightarrow{H_a} \text{Annihilate Scar States, Mix Symmetry Sectors}\)</p> <h4 id="symmetry-breaking-and-scar-formation">Symmetry-Breaking and Scar Formation</h4> <p>Scar states arise when symmetry is broken in a non-generic way. Starting with a small corner of the Hilbert space isolated by symmetry, we find terms that break this symmetry but annihilate this specific corner of the Hilbert space.</p> <p><strong>Symmetry-Breaking Process:</strong> \(\text{Start with: Small Corner of Hilbert Space (Isolated by Symmetry)} \xrightarrow{\text{Symmetry Breaking}} \text{Annihilate Corner, Preserve Scar States}\)</p> <h4 id="group-invariance-in-scar-sectors">Group Invariance in Scar Sectors</h4> <p>In most models, the scar sector is invariant under a “large” group whose rank is proportional to the number of lattice sites. This group is not the symmetry of the Hamiltonian itself. In scar states, the entanglement entropy \(S\) grows logarithmically with the system size \(N\).</p> <p><strong>Group Invariance:</strong> \(\text{Scar Sector Invariance} \leftarrow \text{"Large" Group (Rank} \propto L\text{)}\) \(S \sim \log(N) \text{ in Scar States}\)</p> <p>to be continued…</p> </d-article> <d-appendix> <d-footnote-list></d-footnote-list> <d-citation-list></d-citation-list> </d-appendix> <d-bibliography src="/assets/bibliography/2018-12-22-distill.bib"></d-bibliography> </div> <footer class="fixed-bottom"> </footer> <script src="https://cdn.jsdelivr.net/npm/bootstrap@4.6.1/dist/js/bootstrap.bundle.min.js" integrity="sha256-fgLAgv7fyCGopR/gBNq2iW3ZKIdqIcyshnUULC4vex8=" crossorigin="anonymous"></script> <script src="https://cdn.jsdelivr.net/npm/mdbootstrap@4.20.0/js/mdb.min.js" integrity="sha256-NdbiivsvWt7VYCt6hYNT3h/th9vSTL4EDWeGs5SN3DA=" crossorigin="anonymous"></script> <script type="text/javascript">function progressBarSetup(){"max"in document.createElement("progress")?(initializeProgressElement(),$(document).on("scroll",function(){progressBar.attr({value:getCurrentScrollPosition()})}),$(window).on("resize",initializeProgressElement)):(resizeProgressBar(),$(document).on("scroll",resizeProgressBar),$(window).on("resize",resizeProgressBar))}function getCurrentScrollPosition(){return $(window).scrollTop()}function initializeProgressElement(){let e=$("#navbar").outerHeight(!0);$("body").css({"padding-top":e}),$("progress-container").css({"padding-top":e}),progressBar.css({top:e}),progressBar.attr({max:getDistanceToScroll(),value:getCurrentScrollPosition()})}function getDistanceToScroll(){return $(document).height()-$(window).height()}function resizeProgressBar(){progressBar.css({width:getWidthPercentage()+"%"})}function getWidthPercentage(){return getCurrentScrollPosition()/getDistanceToScroll()*100}const progressBar=$("#progress");window.onload=function(){setTimeout(progressBarSetup,50)};</script> </body> </html>